// Generated by CoffeeScript 1.6.3
/*
registers

0000 = zero
0001 = one
0010 = accu
0011 = register1
0100 = register2
0101 = register3
0110 = register4
0111 = register5
1111 = position (better not use this one!)

commands

1000 = <not yet planned>
1001 = LOADL from following to accu //for longer addresses if needed
1010 = SAVEL to following to accu //for longer addresses if needed
1011 = LOADR to reg1 from address
1100 = SAVER from reg2 to address
1101 = EQUALN values of reg1 and reg2 lead to a jump to pos+n
1110 = <not yet planned>
1111 = <not yet planned>

00000000 = QUIT
00000001 = LOAD from following to accu 
00000010 = SAVE to following to accu 
00000011 = ADD reg1 to reg2 and put value into accu
00000100 = SUB reg2 from reg1 and put value into accu
00000101 = JUMP to given address
00000110 = EQUAL values of reg1 and reg2 lead to a jump to position+2
00000111 = GREATER values of reg1 than reg2 lead to a jump to position+2
00001000 = SMALLER values of reg1 than reg2 lead to a jump to position+2
00001001 = INEQUAL values of reg1 and reg2 lead to a jump to position+2
00001010 = COPY value of reg1 into reg2
00001011 = MULTIPLY reg1 and reg2 and put value into accu
00001100 = SHIFTLEFT reg1 by n
00001101 = SHIFTRIGHT reg2 by n
00001110 = <not yet planned>
00001111 = <not yet planned>
00010000 = <not yet planned>
00010001 = <not yet planned>
00010010 = <not yet planned>
00010011 = <not yet planned>
00010100 = <not yet planned>
00010101 = <not yet planned>
00010110 = <not yet planned>
00010111 = <not yet planned>
00011000 = <not yet planned>
00011000 = <not yet planned>
00011001 = <not yet planned>
00011010 = <not yet planned>
00011011 = <not yet planned>
00011100 = <not yet planned>
00011101 = <not yet planned>
00011110 = <not yet planned>
00011111 = <not yet planned>
		     .
		     .
		     .
01111111 = <not yet planned>
*/


(function() {
  var CELLSIZE, Cell, Controller, HARDDISKSIZE, Harddisk, MEMORYADDRESSSPACE, MEMORYSIZE, Memory, PAGESIZE, bin2Dec, dec2Bin, fitLength, root, translations, type,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  CELLSIZE = 16;

  MEMORYSIZE = 64;

  MEMORYADDRESSSPACE = 8;

  HARDDISKSIZE = 1024;

  PAGESIZE = CELLSIZE * MEMORYSIZE / 2;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  translations = [[/LOADL/g, "1001"], [/SAVEL/g, "1010"], [/LOADR/g, "1011"], [/SAVER/g, "1100"], [/EQUALN/g, "1101"], [/ZERO/g, "0000000000000000"], [/EMPTY/g, "00000000"], [/QUIT/g, "00000000"], [/LOAD/g, "00000001"], [/SAVE/g, "00000010"], [/ADD/g, "00000011"], [/SUB/g, "00000100"], [/JUMP/g, "00000101"], [/EQUAL/g, "00000110"], [/GREATER/g, "00000111"], [/SMALLER/g, "00001000"], [/UNEQUAL/g, "00001001"], [/COPY/g, "00001010"], [/MULTIPLY/g, "00001011"], [/MUL/g, "00001011"], [/SHIFTLEFT/g, "00001100"], [/SHIFTRIGHT/g, "00001101"]];

  type = function(obj) {
    var classToType;
    if (obj === void 0 || obj === null) {
      return String(obj);
    }
    classToType = {
      '[object Boolean]': 'boolean',
      '[object Number]': 'number',
      '[object String]': 'string',
      '[object Function]': 'function',
      '[object Array]': 'array',
      '[object Date]': 'date',
      '[object RegExp]': 'regexp',
      '[object Object]': 'object'
    };
    return classToType[Object.prototype.toString.call(obj)];
  };

  dec2Bin = function(dec, length) {
    var out;
    out = "";
    while (length--) {
      out += (dec >> length) & 1;
    }
    return out;
  };

  bin2Dec = function(bin) {
    var char, i, out, value, _i, _ref;
    out = 0;
    for (i = _i = 0, _ref = bin.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      char = bin.charAt(bin.length - 1 - i);
      value = char === "1" ? 1 : 0;
      out += Math.pow(2, i) * value;
    }
    return out;
  };

  fitLength = function(string, desiredLength, fillSymbol, inEnd) {
    var appendix, difference, i, _i;
    if (fillSymbol == null) {
      fillSymbol = " ";
    }
    if (inEnd == null) {
      inEnd = true;
    }
    difference = desiredLength - string.length;
    if (difference < 0) {
      console.error("" + string + " string is longer than desiredLength");
    }
    if (difference === 0) {
      return string;
    }
    appendix = "";
    for (i = _i = 1; 1 <= difference ? _i <= difference : _i >= difference; i = 1 <= difference ? ++_i : --_i) {
      appendix += fillSymbol;
    }
    if (inEnd) {
      return string + appendix;
    } else {
      return appendix + string;
    }
  };

  root.compileToAssembler = function(string, debug) {
    var directiveType, line, lines, result, split, translation, userTranslations, varDef, varnameRegEx, _i, _j, _k, _len, _len1, _len2;
    if (debug == null) {
      debug = false;
    }
    result = [];
    lines = string.split("\n");
    if (debug) {
      console.log("converting code: ");
    }
    userTranslations = [];
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      if (line.charAt(0) === "*") {
        split = line.split('#', 1);
        line = split[0];
        if (line.length > 3) {
          directiveType = line.charAt(1) + line.charAt(2) + line.charAt(3);
          switch (directiveType) {
            case "set":
              l;
              break;
            case "var":
              varDef = line.slice(5).split(" = ");
              varnameRegEx = new RegExp(varDef[0], "g");
              userTranslations.push([varnameRegEx, varDef[1]]);
          }
        }
        line = "";
      }
      for (_j = 0, _len1 = userTranslations.length; _j < _len1; _j++) {
        translation = userTranslations[_j];
        line = line.replace(translation[0], translation[1]);
      }
      for (_k = 0, _len2 = translations.length; _k < _len2; _k++) {
        translation = translations[_k];
        line = line.replace(translation[0], translation[1]);
      }
      line = line.replace(/\s/g, '');
      split = line.split('#', 1);
      line = split[0];
      if (debug) {
        console.log(line);
      }
      if (line.length !== 0) {
        result.push(line);
      }
    }
    if (debug) {
      console.log(" ");
    }
    return result;
  };

  Cell = (function() {
    function Cell(locked) {
      var i, _i, _ref;
      if (locked == null) {
        locked = false;
      }
      this.lock = __bind(this.lock, this);
      this.setValue = __bind(this.setValue, this);
      this.getValue = __bind(this.getValue, this);
      this.shiftRight = __bind(this.shiftRight, this);
      this.shiftLeft = __bind(this.shiftLeft, this);
      this.setContent = __bind(this.setContent, this);
      this.setFromBinary = __bind(this.setFromBinary, this);
      this.getBeautiful = __bind(this.getBeautiful, this);
      this.getAddress = __bind(this.getAddress, this);
      this.getAsBinary = __bind(this.getAsBinary, this);
      this.getContent = __bind(this.getContent, this);
      this.locked = locked;
      this.content = [];
      for (i = _i = 0, _ref = CELLSIZE - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.content.push(false);
      }
    }

    Cell.prototype.getContent = function() {
      return this.content;
    };

    Cell.prototype.getAsBinary = function() {
      var i, result, _i, _len, _ref;
      result = "";
      _ref = this.content;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        result += (i ? "1" : "0");
      }
      return result;
    };

    Cell.prototype.getAddress = function() {
      var i, result, _i, _len, _ref;
      result = "";
      _ref = this.content.slice(8, 16);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        result += (i ? "1" : "0");
      }
      return result;
    };

    Cell.prototype.getBeautiful = function() {
      var counter, i, result, _i, _len, _ref;
      result = "";
      counter = 0;
      _ref = this.content;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (counter === 8) {
          counter = 0;
          result += " ";
        }
        result += (i ? "1" : "0");
        counter++;
      }
      return result;
    };

    Cell.prototype.setFromBinary = function(string) {
      var bitValue, i, tmp, _i, _ref;
      if (this.locked) {
        console.error("CELL ERROR: tried to write to locked cell");
        return;
      }
      if (type(string) !== "string") {
        console.error("CELL ERROR: type of input must be string");
        return;
      }
      if (string.length !== CELLSIZE) {
        console.error("CELL ERROR: wrong input length");
        return;
      }
      tmp = this.content.slice(0);
      for (i = _i = 0, _ref = CELLSIZE - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        bitValue = string.charAt(i);
        if (bitValue === "0") {
          this.content[i] = false;
        } else if (bitValue === "1") {
          this.content[i] = true;
        } else {
          console.error("CELL ERROR: input must only contain 1 and 0");
          this.content = tmp;
          return;
        }
      }
    };

    Cell.prototype.setContent = function(array) {
      var bitValue, i, _i, _ref;
      if (this.locked) {
        console.error("CELL ERROR: tried to write to locked cell");
        return;
      }
      if (type(array) !== "array") {
        console.error("CELL ERROR: type of input must be array");
        return;
      }
      if (array.length !== CELLSIZE) {
        console.error("CELL ERROR: wrong input length");
        return;
      }
      for (i = _i = 0, _ref = CELLSIZE - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        bitValue = array[i];
        if (type(bitValue) !== "boolean") {
          console.error("CELL ERROR: input must be boolean only array");
          return;
        }
      }
      return this.content = array.slice(0);
    };

    Cell.prototype.shiftLeft = function(n) {
      var i, _i, _results;
      if (n >= MEMORYSIZE) {
        this.content = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
        return;
      }
      _results = [];
      for (i = _i = 0; 0 <= n ? _i <= n : _i >= n; i = 0 <= n ? ++_i : --_i) {
        this.content.push(false);
        _results.push(this.content.shift());
      }
      return _results;
    };

    Cell.prototype.shiftRight = function(n) {
      var i, _i, _results;
      if (n >= MEMORYSIZE) {
        this.content = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
        return;
      }
      _results = [];
      for (i = _i = 0; 0 <= n ? _i <= n : _i >= n; i = 0 <= n ? ++_i : --_i) {
        this.content.unshift(false);
        _results.push(this.content.pop());
      }
      return _results;
    };

    Cell.prototype.getValue = function() {
      var i, result, value, _i;
      result = 0;
      for (i = _i = 1; 1 <= CELLSIZE ? _i <= CELLSIZE : _i >= CELLSIZE; i = 1 <= CELLSIZE ? ++_i : --_i) {
        value = this.content[CELLSIZE - i] ? 1 : 0;
        result += Math.pow(2, i - 1) * value;
      }
      return result;
    };

    Cell.prototype.setValue = function(value) {
      if (this.locked) {
        console.error("CELL ERROR: tried to write to locked cell");
        return;
      }
      return this.setFromBinary(dec2Bin(value, CELLSIZE));
    };

    Cell.prototype.lock = function() {
      return this.locked = true;
    };

    return Cell;

  })();

  Memory = (function() {
    function Memory(size) {
      var cell, i, _i, _j, _len, _ref, _ref1;
      if (size == null) {
        size = MEMORYSIZE;
      }
      this.getBeautifulAt = __bind(this.getBeautifulAt, this);
      this.getBeautiful = __bind(this.getBeautiful, this);
      this.getAsBinary = __bind(this.getAsBinary, this);
      this.getContent = __bind(this.getContent, this);
      this.getValue = __bind(this.getValue, this);
      this.setContent = __bind(this.setContent, this);
      this.setFromBinary = __bind(this.setFromBinary, this);
      this.setValue = __bind(this.setValue, this);
      this.getAsBinaryAt = __bind(this.getAsBinaryAt, this);
      this.getContentAt = __bind(this.getContentAt, this);
      this.getValueAt = __bind(this.getValueAt, this);
      this.setContentAt = __bind(this.setContentAt, this);
      this.setFromBinaryAt = __bind(this.setFromBinaryAt, this);
      this.setValueAt = __bind(this.setValueAt, this);
      this.setFromBinaryArray = __bind(this.setFromBinaryArray, this);
      this.size = size;
      this.alias = [];
      this.cells = [];
      for (i = _i = 0, _ref = size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.cells.push(new Cell());
      }
      _ref1 = this.cells;
      for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
        cell = _ref1[i];
        this.alias[dec2Bin(i, MEMORYADDRESSSPACE)] = cell;
      }
    }

    Memory.prototype.printMemoryAsBinary = function() {
      var cell, fittingLength, i, _i, _len, _ref, _results;
      fittingLength = this.size.toString().length + 1;
      _ref = this.cells;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        cell = _ref[i];
        _results.push(console.log(fitLength("" + i, fittingLength) + ": " + cell.getBeautiful()));
      }
      return _results;
    };

    Memory.prototype.setFromBinaryArray = function(array) {
      var i, string, _i, _len, _results;
      if (type(array) !== "array") {
        console.error("MEMORY ERROR: input type must be array");
        return;
      }
      if (array.length > this.size) {
        console.error("MEMORY ERROR: input array must not be longer than memory");
        return;
      }
      _results = [];
      for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
        string = array[i];
        _results.push(this.setFromBinaryAt(i, string));
      }
      return _results;
    };

    Memory.prototype.setValueAt = function(position, value) {
      if (position < 0 || position >= MEMORYSIZE) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return this.cells[position].setValue(value);
    };

    Memory.prototype.setFromBinaryAt = function(position, string) {
      if (position < 0 || position >= MEMORYSIZE) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return this.cells[position].setFromBinary(string);
    };

    Memory.prototype.setContentAt = function(position, content) {
      if (position < 0 || position >= MEMORYSIZE) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return this.cells[position].setContent(content);
    };

    Memory.prototype.getValueAt = function(position) {
      if (position < 0 || position >= MEMORYSIZE) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return this.cells[position].getValue();
    };

    Memory.prototype.getContentAt = function(position) {
      if (position < 0 || position >= MEMORYSIZE) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return this.cells[position].getContent();
    };

    Memory.prototype.getAsBinaryAt = function(position) {
      if (position < 0 || position >= MEMORYSIZE) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return this.cells[position].getAsBinary();
    };

    Memory.prototype.setValue = function(position, value) {
      var cell;
      cell = null;
      if (cell == null) {
        cell = this.alias[position];
      }
      console.log(cell);
      if (cell == null) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return cell.setValue(value);
    };

    Memory.prototype.setFromBinary = function(position, string) {
      var cell;
      cell = null;
      if (cell == null) {
        cell = this.alias[position];
      }
      console.log(cell);
      if (cell == null) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return cell.setFromBinary(string);
    };

    Memory.prototype.setContent = function(position, content) {
      var cell;
      cell = null;
      if (cell == null) {
        cell = this.alias[position];
      }
      console.log(cell);
      if (cell == null) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return cell.setContent(content);
    };

    Memory.prototype.getValue = function(position) {
      var cell;
      cell = null;
      if (cell == null) {
        cell = this.alias[position];
      }
      console.log(cell);
      if (cell == null) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return cell.getValue();
    };

    Memory.prototype.getContent = function(position) {
      var cell;
      cell = null;
      if (cell == null) {
        cell = this.alias[position];
      }
      console.log(cell);
      if (cell == null) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return cell.getContent();
    };

    Memory.prototype.getAsBinary = function(position) {
      var cell;
      cell = null;
      if (cell == null) {
        cell = this.alias[position];
      }
      console.log(cell);
      if (cell == null) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return cell.getAsBinary();
    };

    Memory.prototype.getBeautiful = function(position) {
      var cell;
      cell = null;
      if (cell == null) {
        cell = this.alias[position];
      }
      console.log(cell);
      if (cell == null) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return cell.getBeautiful();
    };

    Memory.prototype.getBeautifulAt = function(position) {
      if (position < 0 || position >= MEMORYSIZE) {
        console.error("MEMORY ERROR: position not in Memory");
        return;
      }
      return this.cells[position].getBeautiful();
    };

    return Memory;

  })();

  Harddisk = (function() {
    function Harddisk(size, pagesize) {
      if (size == null) {
        size = HARDDISKSIZE;
      }
      if (pagesize == null) {
        pagesize = PAGESIZE;
      }
    }

    return Harddisk;

  })();

  Controller = (function() {
    function Controller() {
      this.doTick = __bind(this.doTick, this);
      this.printStatus = __bind(this.printStatus, this);
      this.getRegister = __bind(this.getRegister, this);
      this.run = __bind(this.run, this);
      this.emptyRegisters = __bind(this.emptyRegisters, this);
      this.loadMemoryFromArray = __bind(this.loadMemoryFromArray, this);
      this.running = false;
      this.memory = new Memory();
      this.accu = new Cell();
      this.position = new Cell();
      this.register1 = new Cell();
      this.register2 = new Cell();
      this.register3 = new Cell();
      this.register4 = new Cell();
      this.register5 = new Cell();
      this.zero = new Cell(true);
      this.one = new Cell();
      this.one.setValue(1);
      this.one.lock();
    }

    Controller.prototype.loadMemoryFromArray = function(array) {
      return this.memory.setFromBinaryArray(array);
    };

    Controller.prototype.emptyRegisters = function() {
      this.accu.setContent(this.zero.getContent());
      this.position.setContent(this.zero.getContent());
      this.register1.setContent(this.zero.getContent());
      this.register2.setContent(this.zero.getContent());
      this.register3.setContent(this.zero.getContent());
      this.register4.setContent(this.zero.getContent());
      return this.register5.setContent(this.zero.getContent());
    };

    Controller.prototype.run = function(start, debug) {
      var oldtime;
      if (start == null) {
        start = 0;
      }
      if (debug == null) {
        debug = false;
      }
      if (debug) {
        oldtime = (new Date).getTime();
      }
      if (start < 0 || start >= MEMORYSIZE) {
        console.error("CONTROLLER ERROR: startposition must be in memory");
        return;
      }
      if (start !== 0) {
        this.position.setValue(start);
      }
      this.running = true;
      if (debug) {
        console.log(" ");
        console.log("Debug data from run of Controller: ");
        console.log(" ");
      }
      while (this.running) {
        this.doTick(debug);
      }
      if (debug) {
        this.printStatus();
        console.log(" ");
        return console.log("Programm took: " + ((new Date).getTime() - oldtime) + "ms to run");
      }
    };

    Controller.prototype.getRegister = function(register) {
      switch (register) {
        case "0000":
          return this.zero;
        case "0001":
          return this.one;
        case "0010":
          return this.accu;
        case "0011":
          return this.register1;
        case "0100":
          return this.register2;
        case "0101":
          return this.register3;
        case "0110":
          return this.register4;
        case "0111":
          return this.register5;
        case "1111":
          return this.position;
        default:
          console.error("CONTROLLER ERROR: given register " + register + " is not existing");
          this.running = false;
      }
    };

    Controller.prototype.printStatus = function() {
      console.log(" ");
      console.log(this.running ? "Controller is running" : "Controller is not running");
      console.log(" ");
      console.log("Registers:");
      console.log(" ");
      console.log("accu : " + this.accu.getBeautiful());
      console.log("register1 : " + this.register1.getBeautiful());
      console.log("register2 : " + this.register2.getBeautiful());
      console.log("register3 : " + this.register3.getBeautiful());
      console.log("register4 : " + this.register4.getBeautiful());
      console.log("position : " + this.position.getBeautiful());
      console.log("zero : " + this.zero.getBeautiful() + " warning this must alway be the equal of 0, if its not bad things WILL happen");
      console.log("one : " + this.one.getBeautiful() + " warning this must alway be the equal of 1, if its not bad things WILL happen");
      console.log(" ");
      console.log("Memory:");
      console.log(" ");
      return this.memory.printMemoryAsBinary();
    };

    Controller.prototype.doTick = function(debug) {
      var arg, cmd, n, pos, position, reg, reg1, reg2, tmp;
      if (debug == null) {
        debug = false;
      }
      pos = this.position.getValue();
      if (debug) {
        console.log(" ");
        console.log("tick:");
        console.log("position: " + pos);
      }
      if ((0 < pos && pos >= MEMORYSIZE)) {
        console.error("CONTROLLER ERROR: position is not in memory");
        this.running = false;
        return;
      }
      tmp = this.memory.getAsBinaryAt(pos);
      if (debug) {
        console.log("processing: " + this.memory.getBeautifulAt(pos));
      }
      cmd = "";
      arg = "";
      if (tmp.charAt(0) === "1") {
        cmd = tmp.slice(0, 4);
        arg = tmp.slice(4);
      } else {
        cmd = tmp.slice(0, 8);
        arg = tmp.slice(8);
      }
      if (debug) {
        console.log("split to " + cmd + " and " + arg);
      }
      switch (cmd) {
        case "00000000":
          if (debug) {
            console.log("QUIT");
          }
          this.running = false;
          break;
        case "1001":
        case "00000001":
          if (debug) {
            console.log("LOAD to accu from " + arg + " (" + (bin2Dec(arg)) + ")");
          }
          this.accu.setContent(this.memory.getContent(arg));
          break;
        case "1010":
        case "00000010":
          if (debug) {
            console.log("SAVE from accu to " + arg + " (" + (bin2Dec(arg)) + ")");
          }
          this.memory.setContent(arg, this.accu.getContent());
          break;
        case "1011":
          reg = arg.slice(0, 4);
          position = arg.slice(4);
          if (debug) {
            console.log("LOAD to reg (" + reg + ") from " + position + " (" + (bin2Dec(position)) + ")");
          }
          this.getRegister(reg).setContent(this.memory.getContent(position));
          break;
        case "1100":
          reg = arg.slice(0, 4);
          position = arg.slice(4);
          if (debug) {
            console.log("SAVE from reg (" + reg + ") to " + position + " (" + (bin2Dec(position)) + ")");
          }
          this.memory.setContent(position, this.getRegister(reg).getContent());
          break;
        case "1101":
          reg1 = arg.slice(0, 4);
          reg2 = arg.slice(4, 8);
          n = arg.slice(8);
          if (debug) {
            console.log("EQUAL values of reg1 (" + reg1 + ") and reg2 (" + reg2 + ") lead to a relative jump of n (" + (bin2Dec(n)) + ")");
          }
          if (this.getRegister(reg1).getValue() === this.getRegister(reg2).getValue()) {
            this.position.setValue(this.position.getValue() + bin2Dec(n) - 1);
          }
          break;
        case "00000011":
          reg1 = arg.slice(0, 4);
          reg2 = arg.slice(4);
          if (debug) {
            console.log("ADD reg1 (" + reg1 + ") and reg2 (" + reg2 + ") and save to accu");
          }
          this.accu.setValue(this.getRegister(reg1).getValue() + this.getRegister(reg2).getValue());
          break;
        case "00000100":
          reg1 = arg.slice(0, 4);
          reg2 = arg.slice(4);
          if (debug) {
            console.log("SUB reg2 (" + reg2 + ") from reg1 (" + reg1 + ") and save to accu");
          }
          this.accu.setValue(this.getRegister(reg1).getValue() - this.getRegister(reg2).getValue());
          break;
        case "00000101":
          if (debug) {
            console.log("JUMP to position " + arg + " (" + (bin2Dec(arg)) + ")");
          }
          this.position.setFromBinary(fitLength(arg, 16, "0", false));
          return;
        case "00000110":
          reg1 = arg.slice(0, 4);
          reg2 = arg.slice(4);
          if (debug) {
            console.log("EQUAL values of reg1 (" + reg1 + ") and reg2 (" + reg2 + ") lead to a relative jump of 2");
          }
          if (this.getRegister(reg1).getValue() === this.getRegister(reg2).getValue()) {
            this.position.setValue(this.position.getValue() + 1);
          }
          break;
        case "00000111":
          reg1 = arg.slice(0, 4);
          reg2 = arg.slice(4);
          if (debug) {
            console.log("GREATER values of reg1 (" + reg1 + ") than reg2 (" + reg2 + ") lead to a relative jump of 2");
          }
          if (this.getRegister(reg1).getValue() > this.getRegister(reg2).getValue()) {
            this.position.setValue(this.position.getValue() + 1);
          }
          break;
        case "00001000":
          reg1 = arg.slice(0, 4);
          reg2 = arg.slice(4);
          if (debug) {
            console.log("SMALLER values of reg1 (" + reg1 + ") than reg2 (" + reg2 + ") lead to a relative jump of 2");
          }
          if (this.getRegister(reg1).getValue() < this.getRegister(reg2).getValue()) {
            this.position.setValue(this.position.getValue() + 1);
          }
          break;
        case "00001001":
          reg1 = arg.slice(0, 4);
          reg2 = arg.slice(4);
          if (debug) {
            console.log("UNEQUAL values of reg1 (" + reg1 + ") than reg2 (" + reg2 + ") lead to a relative jump of 2");
          }
          if (this.getRegister(reg1).getValue() !== this.getRegister(reg2).getValue()) {
            this.position.setValue(this.position.getValue() + 1);
          }
          break;
        case "00001010":
          reg1 = arg.slice(0, 4);
          reg2 = arg.slice(4);
          if (debug) {
            console.log("COPY values of reg1 (" + reg1 + ") into reg2(" + reg2 + ")");
          }
          this.getRegister(reg2).setContent(this.getRegister(reg1).getContent());
          break;
        case "00001011":
          reg1 = arg.slice(0, 4);
          reg2 = arg.slice(4);
          if (debug) {
            console.log("MULTIPLY reg1 (" + reg1 + ") and reg2 (" + reg2 + ") and save to accu");
          }
          this.accu.setValue(this.getRegister(reg1).getValue() * this.getRegister(reg2).getValue());
          break;
        case "00001100":
          reg1 = arg.slice(0, 4);
          n = arg.slice(4);
          if (debug) {
            console.log("SHIFTLEFT reg1 (" + reg1 + ") by n (" + (bin2Dec(n)) + ")");
          }
          this.getRegister(reg1).shiftLeft(bin2Dec(n));
          break;
        case "00001101":
          reg1 = arg.slice(0, 4);
          n = arg.slice(4);
          if (debug) {
            console.log("SHIFTRIGHT reg1 (" + reg1 + ") by n (" + (bin2Dec(n)) + ")");
          }
          this.getRegister(reg1).shiftRight(bin2Dec(n));
          break;
        default:
          console.error("CONTROLLER ERROR: this command " + cmd + " is not known");
          this.running = false;
          return;
      }
      return this.position.setValue(this.position.getValue() + 1);
    };

    return Controller;

  })();

  root.Controller = Controller;

  root.Memory = Memory;

  root.Cell = Cell;

}).call(this);
